import{_ as i,c as l,o as a,ae as n}from"./chunks/framework.CgiyRsxg.js";const d=JSON.parse('{"title":"第二章 第四节 Server类和PluginManager类","description":"","frontmatter":{},"headers":[],"relativePath":"第二章/2-4_Server类和PluginManager类.md","filePath":"第二章/2-4_Server类和PluginManager类.md"}'),t={name:"第二章/2-4_Server类和PluginManager类.md"};function r(s,e,g,p,o,u){return a(),l("div",null,[...e[0]||(e[0]=[n(`<h1 id="第二章-第四节-server类和pluginmanager类" tabindex="-1">第二章 第四节 Server类和PluginManager类 <a class="header-anchor" href="#第二章-第四节-server类和pluginmanager类" aria-label="Permalink to &quot;第二章 第四节 Server类和PluginManager类&quot;">​</a></h1><p>参与编写者: MagicLu550</p><h4 id="建议学习时间-20分钟" tabindex="-1">建议学习时间: 20分钟 <a class="header-anchor" href="#建议学习时间-20分钟" aria-label="Permalink to &quot;建议学习时间: 20分钟&quot;">​</a></h4><h5 id="学习要点-了解server类和pluginmanager类" tabindex="-1">学习要点: 了解Server类和PluginManager类 <a class="header-anchor" href="#学习要点-了解server类和pluginmanager类" aria-label="Permalink to &quot;学习要点: 了解Server类和PluginManager类&quot;">​</a></h5><p>一. Server</p><p>1.概述</p><p>Server类是插件几乎所有接口的入口，几乎一切的接口都是基于这个类获得的,而在nukkit中,Server类 是作为一个对象单独存在,Server的实例化意味着nukkit服务器的启动,并且不允许外部调用其构造方法,但可以根据getInstance方法或者插件主类提供的 getServer方法可以获得,这里我们提到了两个获得Server的方法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>    Server.getInstance();</span></span>
<span class="line"><span>    this.getServer();//this.getClass() == mainClass</span></span></code></pre></div><p>Server对象是在Nukkit类里完成初始化的,所以我们不需要担心Server对象是否存在的问题.加载插件 前,Server对象已经存在.一切启动的初始化操作都在Server的构造方法中完成.对于Server的复杂原理, 这里不过多赘述,可以参见第四部分的内容</p><p>Nukkit.java Line. 108-115</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            if (TITLE) {</span></span>
<span class="line"><span>                System.out.print((char) 0x1b + &quot;]0;Nukkit is starting up...&quot; + (char) 0x07);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            new Server(PATH, DATA_PATH, PLUGIN_PATH, language);</span></span>
<span class="line"><span>        } catch (Throwable t) {</span></span>
<span class="line"><span>            log.throwing(t);</span></span>
<span class="line"><span>        }</span></span></code></pre></div><ol start="2"><li>Server类的常用方法 <ul><li>addOp(String) 可以添加op管理员的名称,name是玩家名称</li><li>addWhitelist(String) 可以添加白名单</li><li>batchPackets​(Player[], DataPacket[]) 批量发送数据包,后面<a href="./2-7_如何发送数据包.html">数据包发送篇</a>详细讲解</li><li>broadMessage(String) 发送服务器广播信息，所有玩家可见</li><li>addRecipe​(Recipe) 添加配方,这个配方指包括合成、炉子、炼药台等使用的配方。</li><li>broadcastPacket​(Player[], DataPacket) 向所有玩家广播数据包</li><li>forceShutdown() 强制关闭服务端</li><li>doAutoSave() 自动保存</li><li>generateLevel​(String) 产生一个level(世界),String为名字,返回创建是否成功</li><li>getAllowFlight() 获得这个服务器是否是允许飞行的</li><li>getApiVersion() 获取插件api的版本</li><li>getCommandAliases() 将返回以(一个指令名对应着多个别名)为一对的Map集合</li><li>getCommandMap() 获取指令Map,通过它可以注册一些命令,<a href="./../第一章/1-4_如何编写命令.html">前面已经说到过</a></li><li>getDataPath() 获取服务端的数据目录</li><li>getDefaultGamemode() 获取服务端的默认模式(如创造模式等)</li><li>getDefaultLevel() 获取默认的世界对象,如World</li><li>getDifficulty() 获得游戏难度，如和平模式等</li><li>getIp() 获得服务端的ip地址</li><li>getIpBans() 获得封禁的信息(ban)</li><li>getLanguage() 获得服务端默认语言(如zh等)</li><li>getLevelByName(String) 通过世界名称获得世界对象</li><li>getMaxPlayers() 获得最大人数</li><li>getMotd() 获得服务端的motd</li><li>getName() 获得服务端的名称</li><li>getNameBans() 获得迸封禁的玩家表</li><li>getOfflinePlayer(String) 通过玩家名称得到不在线玩家</li><li>getOnlinePlayers() 获得在线玩家,UUID都是唯一的标识符</li><li>getPlayerExact(String) 通过名称获得一个确切的玩家​</li><li>getPluginManager() 获得插件管理器</li><li>getOps() 获得管理员清单</li><li>getPort() 获得端口</li><li>getPluginPath() 获得插件文件夹的位置</li><li>getScheduler() 获得任务表，可以注册有关多线程之类的东西</li><li>getSubMotd() 获得附属的motd</li><li>hasWhitelist() 是否有白名单</li><li>isOp​(String) 判断一个玩家是否是op,String为玩家名称</li><li>reload() 重启服务端</li><li>reloadWhitelist() 重新加载白名单</li><li>removeOnlinePlayer​(Player) 删除在线玩家</li><li>removeOp​(String) 删除指定管理员</li><li>removeWhitelist​(String) 删除一个玩家的白名单</li><li>shutdown() 关闭服务端</li><li>unloadLevel​(Level) 卸载一个世界</li></ul></li></ol><p>二. PluginManager</p><ol><li><p>概述 PluginManager是插件管理器,很多的插件加载和数据储存都在这里进行,如监听器 的注册等 使用这个类也可以实现动态加载插件等一系列的操作,PluginManager的加载基于JavaPluginLoader</p></li><li><p>常用的方法</p><ul><li>addPermission(Permission) 添加Permission对象</li><li>callEvent(Event) 触发一个事件</li><li>clearPlugins() 清空插件</li><li>disablePlugin(Plugin) 停止一个插件，这个插件会提前调用onDisable 并卸载</li><li>getPlugin​(String) 得到其他插件的插件对象</li><li>loadPlugin​(File) 加载一个插件，路径默认为服务端根目录</li><li>loadPlugins​(File) 加载一个文件夹的插件</li><li>registerEvents​(Listener, Plugin) 注册监听器</li><li>removePermission​(String) 删除一个Permission</li></ul></li></ol>`,14)])])}const v=i(t,[["render",r]]);export{d as __pageData,v as default};
